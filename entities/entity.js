"use strict";

//  ===================================================[ IMPORTS ]

import { Rectangle, Timer, Vector } from "../utilities/index.js";

// |===================================================|
// |                     SPRITE                        |
// |===================================================|
// | Rendering related data, sprite (and entity)       |
// | state, responsible for advancing animation frames |
// |===================================================|

class Sprite {
    // asset
    spritesheet;
    atlas;

    // animation
    state;
    frame;
    timer;

    // advanced rendering logic
    // * tracks if animation has completed one cycle
    // * should animation loop and repeat
    // * manual frame duration for a given animation loop
    finished;
    repeat;
    frame_duration;

    // sets assets, state, and animation related default data 
    // * asset must include image and atlas
    constructor(image, atlas, state) {
        this.spritesheet = image;
        this.atlas = atlas;

        this.state = state;
        this.frame = 0;
        this.timer = new Timer();

        this.finished = false;
        this.repeat = true;
        this.frame_duration = null;

        // start the animation
        this.timer.start(atlas[state][0].duration);
    }

    // advance the animation using the timer
    // on frame change returns true
    next_frame(dt) {
        if (this.finished && !this.repeat) {
            return false;
        }
        if (this.timer.decrement(dt)) {
            let frames = this.atlas[this.state];
            let num_frames = frames.length;
            let next_frame = (this.frame + 1) % num_frames;

            if (next_frame == 0) {
                this.finished = true;
                if (!this.repeat) {
                    return;
                }
            }

            let duration = this.frame_duration === null ?
                frames[next_frame].duration : this.frame_duration;
            this.frame = next_frame;
            this.timer.start(duration);

            return true;
        }
        return false;
    }

    // returns true if the current animation has looped at least once
    is_finished() {
        return this.finished;
    }

    // get frame data of current action and frame
    get_frame_data() {
        let frame_data = this.atlas[this.state][this.frame];
        let texture = frame_data.texture;

        return {
            texture: new Rectangle(new Vector(texture.u, texture.v), new Vector(texture.w, texture.h)),
            anchor: new Vector(frame_data.anchor.x, frame_data.anchor.y)
        }
    }

    // get the total number of frames for the provided or current state (animation)
    get_frame_count(state = null) {
        state ??= this.state;
        return this.atlas[state].length;
    }

    // switching state does not reset animation data
    switch_state(state) {
        this.state = state;
    }

    // setters
    // * changing state resets animation data
    set_state(state) {
        this.state = state;
        this.frame = 0;

        this.finished = false;
        this.repeat = true;
        this.frame_duration = null;

        this.timer.start(this.atlas[state][0].duration);
    }

    set_repeat(bool) {
        this.repeat = bool;
    }

    set_finished(bool) {
        this.finished = bool;
    }

    set_frame_duration(dt) {
        this.frame_duration = dt;

        this.timer.reset();
        this.timer.start(dt);
    }
}

// |===================================================|
// |                    PHYSICS                        |
// |===================================================|
// | Physics related data and methods including:       |
// | position, velocity, acceleration, bounding box,   |
// | integration, and collisions.                      |
// |===================================================|

class Physics {
    // motion
    position;
    trajectory;
    velocity;
    acceleration;
    gravity;

    // collisions
    hitbox;
    midpoint;
    _boundary;

    // sets initial physics state values
    // * hitbox is generated by the current frame
    // * boundary is a reference to the game world boundary
    constructor(position, velocity, acceleration, gravity, hitbox, boundary) {
        // motion data
        this.position = position;
        this.trajectory = new Vector();
        this.velocity = velocity;
        this.acceleration = acceleration;
        this.gravity = gravity;

        // collision check data
        // * consolidates difference in coordinate systems between frames and physics
        this.hitbox = hitbox;
        this.midpoint = hitbox.midpoint();
        this._boundary = boundary;
    }

    // update physics system
    integrate(dt) {
        let delta_velocity = Vector.multiply(this.acceleration, dt);
        this.impulse(delta_velocity);

        let delta_position = Vector.multiply(this.velocity, dt);
        this.move(delta_position);
    }

    // change position
    // * this is the only function that directly modifies position
    move(delta) {
        this.trajectory = delta;
        this.position.add(delta);
        this.midpoint.add(delta);
        this.hitbox.translate(delta);
    }

    // change velocity
    // * this is the only function that directly modifies velocity
    impulse(delta) {
        this.velocity.add(delta);
    }

    // change acceleration
    // * this is the only function that directly modifies acceleration
    jolt(delta) {
        this.acceleration.add(delta);
    }

    // sets the physics state for jumping
    // * add an extremely small value to not trigger boundary collisions for jump logic
    jump(v) {
        let off = Vector.multiply(v, 0.000001);
        this.move(off);
        this.impulse(v);
        this.apply_gravity();
    }

    // sets the physics state for landing after a jump
    land() {
        this.set_position_components(null, 1);
        this.set_velocity_components(0, 0);
        this.apply_gravity(false);
    }

    // returns true if this hitbox is colliding with anothers hitbox
    collides(other) {
        return this.hitbox.collides(other.hitbox);
    }

    // returns true if this this hitbox contains anothers hitbox
    contains(other) {
        return this.hitbox.contains(other.hitbox);
    }

    // returns true if this hitbox is contained by anothers hitbox
    // * either physics or hitbox may be passed
    contained(other) {
        if (other instanceof Rectangle) {
            return this.hitbox.contained(other);
        }
        else {
            return this.hitbox.contained(other.hitbox);
        }
    }

    // returns collision resolution vector along the minimum depth axiis
    resolve_collision(other) {
        if (!this.collides(other)) {
            return new Vector();
        }

        let relative = this.hitbox.relative(other.hitbox);
        let depth = this.hitbox.depth(other.hitbox, relative);

        if (depth.x <= depth.y) {
            if (relative.x < 0) { // collision with right side
                return new Vector(-depth.x, 0);
            }
            else { // left side
                return new Vector(depth.x, 0);
            }
        }
        else {
            if (relative.y < 0) { // collision with bottom side
                return new Vector(0, -depth.y);
            }
            else { // top side
                return new Vector(0, depth.y);
            }
        }
    }

    // resolves collision using translation w.r.t. signed max penetration depths along both axiis
    resolve_boundary(boundary = null) {
        boundary ??= this._boundary;
        if (!this.contained(boundary)) {
            let translation = this.hitbox.difference(boundary);
            this.move(translation);
        }
    }

    // linear interpolation between this physics state and another
    lerp(other, alpha) {
        let new_position = Vector.lerp(this.position, other.position, alpha);
        let new_velocity = Vector.lerp(this.velocity, other.velocity, alpha);
        let new_acceleration = Vector.lerp(this.acceleration, other.acceleration, alpha);

        this.set_position(new_position);
        this.set_velocity(new_velocity);
        this.set_acceleration(new_acceleration);
    }

    // copy this physics object into a new one
    copy() {
        let position = this.position.copy();
        let velocity = this.velocity.copy();
        let acceleration = this.acceleration.copy();
        let gravity = this.gravity.copy();
        let hitbox = this.hitbox.copy();
        let boundary = this._boundary.copy();

        return new Physics(position, velocity, acceleration, gravity, hitbox, boundary);
    }

    // either applies or removes gravitational influence
    apply_gravity(bool = null) {
        bool ??= true;
        if (bool) {
            this.jolt(this.gravity);
        }
        else {
            let gravity_inverse = Vector.multiply(this.gravity, -1);
            this.jolt(gravity_inverse);
        }
    }

    // gets the hitbox as a set of counter-clockwise points
    hitbox_points() {
        return this.hitbox.points();
    }

    // gets the boundary as a set of counter-clockwise points
    boundary_points(boundary = null) {
        boundary ??= this._boundary;
        return boundary.points();
    }

    // setters
    set_position(v) {
        let delta = Vector.subtract(v, this.position);
        this.move(delta);
    }
    set_velocity(v) {
        let delta = Vector.subtract(v, this.velocity);
        this.impulse(delta);
    }
    set_acceleration(v) {
        let delta = Vector.subtract(v, this.acceleration);
        this.jolt(delta);
    }
    set_position_components(x = null, y = null) {
        x ??= this.position.x;
        y ??= this.position.y;
        let v = new Vector(x, y);
        let delta = Vector.subtract(v, this.position);
        this.move(delta);
    }
    set_velocity_components(x = null, y = null) {
        x ??= this.velocity.x;
        y ??= this.velocity.y;
        let v = new Vector(x, y);
        let delta = Vector.subtract(v, this.velocity);
        this.impulse(delta);
    }
    set_acceleration_components(x = null, y = null) {
        x ??= this.acceleration.x;
        y ??= this.acceleration.y;
        let v = new Vector(x, y);
        let delta = Vector.subtract(v, this.acceleration);
        this.jolt(delta);
    }
    set_hitbox(pos, dim) {
        this.hitbox.set(pos, dim);
        this.midpoint = this.hitbox.midpoint();
    }
}


// |===================================================|
// |                    ENTITY                         |
// |===================================================|
// | Superclass of entities in the game, holds a       |
// | reference to its sprite, global audio system,     |
// | and physics. Responsible for managing sprite      |
// | state, and the interactions between physics and   | 
// | sprite.                                           |
// |===================================================|

class Entity {
    // asset and animation
    _sprite;

    // global audio system
    _audio;

    // motion and collisions
    _physics;

    // an entity is responsible for its own sprite, physics, and audio cues
    // * config is found in the config file and sets initial values
    // * asset must include spritesheet and atlas
    // * audio is the global audio system shared across all entities and objects
    // * boundary is a reference to the game world boundary
    constructor(config, asset, audio, boundary) {
        // sprite
        this._sprite = new Sprite(asset.image, asset.atlas, config.state);

        // audio
        this._audio = audio;

        // physics
        let position = Vector.from(config.physics.position);
        let velocity = Vector.from(config.physics.velocity);
        let acceleration = Vector.from(config.physics.acceleration);
        let gravity = Vector.from(config.physics.gravity);

        let frame_data = this._sprite.get_frame_data();
        let hitbox_position = new Vector(position.x - frame_data.anchor.x, position.y + frame_data.anchor.y);
        let hitbox_dimensions = Vector.from(frame_data.texture);
        let hitbox = new Rectangle(hitbox_position, hitbox_dimensions);

        this._physics = new Physics(position, velocity, acceleration, gravity, hitbox, boundary);
    }

    // trigger sprite animation and conditional bounding box change
    // * animation frames vary in dimensions
    animate(dt) {
        let next = this._sprite.next_frame(dt);
        if (next) {
            this.frame_to_hitbox();
        }
    }

    // trigger the physics integration
    integrate(dt) {
        this._physics.integrate(dt);
    }

    // trigger the physics boundary resolution
    resolve_boundary() {
        this._physics.resolve_boundary();
    }

    // update the hitbox when animation frames change
    frame_to_hitbox() {
        let frame_data = this._sprite.get_frame_data();
        let position = new Vector(
            this._physics.position.x - frame_data.anchor.x,
            this._physics.position.y + frame_data.anchor.y
        );
        this._physics.set_hitbox(position, frame_data.texture.dimensions);
    }

    // * changing the state may change the bounding box
    // * changing the state may violate boundary restrictions
    set_state(state) {
        this._sprite.set_state(state);
        this.frame_to_hitbox();
        this._physics.resolve_boundary();
    }

    // switch the entity state without resetting the animation cycle
    // * switching the state may change the bounding box
    // * switching the state may violate boundary restrictions
    switch_state(state) {
        this._sprite.switch_state(state);
        this.frame_to_hitbox();
        this._physics.resolve_boundary();
    }
}

export { Entity }